import timeimport pandas as pdimport importlibimport TsDataProcessorfrom tensorflow.keras.models import Sequentialfrom tensorflow.keras.layers import Dense, Dropout, LSTM, BatchNormalizationfrom tensorflow.keras.callbacks import TensorBoard, ModelCheckpointimport tensorflow as tfimport randomimport Importsimport torchimport osimport numpy as np#import plaidmlimportlib.reload(Imports)importlib.reload(TsDataProcessor)class Parameters:    passp = Parameters()p.TargetTickers = ["BTC"]p.epochs = 5p.Batch_size = 256p.TestProportion = 0.4p.ValidationProportion = 0.1p.hindsight = 512p.hindsight_interval= "1T"p.foresight = 128p.foresight_interval = p.hindsight_intervalp.buy_threshold= 0.02p.sell_threshold= 0.05p.y_name = "close"p.x_names = ["close", "volume", "low", "high", "open"]p.tickers = ['BTC', 'EOS', 'LTC']displace = 0displacer = 0if p.sell_threshold == None:    displace = 1    displacer = 2DFrame, TargetPrice, Price = Imports.ImportTimeseries(p)DFrame = TsDataProcessor.TsDataProcessor(DFrame, t=p.hindsight)testlength = int(p.TestProportion*len(DFrame))test = DFrame.iloc[:testlength]DFrame = DFrame.iloc[testlength:]tensor = TsDataProcessor.Tensify(DFrame, p)if p.sell_threshold == None:    tensor = TsDataProcessor.BalanceTensor(tensor, sum(DFrame["long"]), p)else:    tensor = TsDataProcessor.BalanceTensor(tensor, len(DFrame)-sum(DFrame["none"]), p)tensor = tensor.batch(p.Batch_size).prefetch(1)test = test.merge(Price, how ='inner', left_index=True, right_index=True)test = test.merge(TargetPrice, how ='inner', left_index=True, right_index=True)TestTensor = TsDataProcessor.Tensify(test[test.columns.values[:-5+displacer]], p, Y = False)TestTensor = TestTensor.batch(p.Batch_size).prefetch(1)test = test.iloc[:-p.hindsight+1]del DFrameos.environ["KERAS_BACKEND"] = "plaidml.keras.backend"Model = Sequential()Model.add(LSTM(128, activation = "tanh", return_sequences = True))Model.add(Dropout(0.3))Model.add(BatchNormalization())Model.add(LSTM(128, activation = "tanh", return_sequences = True))Model.add(Dropout(0.3))Model.add(BatchNormalization())Model.add(LSTM(128, activation = "tanh"))Model.add(Dropout(0.3))Model.add(BatchNormalization())Model.add(Dense(32, activation="relu"))Model.add(Dropout(0.2))Model.add(Dense(3-displace, activation="softmax"))opt = tf.keras.optimizers.Adam(lr=0.001 , decay=1e-6)Model.compile(loss="categorical_crossentropy",              optimizer=opt,              metrics=["accuracy"])# NAME = f"{predict}-{hindsight}-SEQ-{foresight}-PRED-{int(time.time())}"## tensorboard = TensorBoard(log_dir="logs/{}".format(NAME))## filepath = "RNN_Final-{epoch:02d}-{val_acc:.3f}"  # unique file name that will include the epoch and the validation acc for that epoch## checkpoint = ModelCheckpoint("models/{}.model".format(filepath, monitor='val_acc', verbose=1, save_best_only=True, mode='max')) # saves only the best oneshistory = Model.fit(tensor, epochs = p.epochs)# Model.evaluate(test_x, test_y)TestPredictions = Model.predict(TestTensor)# TestFrame["Prediction"] = PredictionPrediction = []for sample in TestPredictions:    for i in range(0,3):        if sample[i] == max(sample):            Prediction.append(i)Investment = 1000count = 0for i in range(len(Prediction)-1,-1,-1):    if Prediction[i] == 0:        Investment += ((test[p.TargetTickers[0] + " TargetPrice"].iloc[i]-test[p.TargetTickers[0] + " Price"].iloc[i])/test[p.TargetTickers[0] + " Price"].iloc[i])*10        # if (test[TargetTickers[0] + " TargetPrice"].iloc[i]-test[TargetTickers[0] + " Price"].iloc[i]) > 0:        #     count+= 1    elif Prediction[i] == 1:        Investment += ((test[p.TargetTickers[0] + " Price"].iloc[i] - test[p.TargetTickers[0] + " TargetPrice"].iloc[i]) /                       test[p.TargetTickers[0] + " Price"].iloc[i]) * 10    if Investment < 0:        print("Bust after " + str(i) + " minutes.")        breakif Investment > 0:    print("You made " + str(int(Investment-1000)) + " euros. " + str(int((Investment-1000)/10)) + "% Return in " + str(int(len(Prediction)/6/24)) + " days.")    print(str(sum(Prediction)) + " trades with a " + str(int(count*100/sum(Prediction))) + "% success rate.")